<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title></title>
  <meta name="CREATED" content="20061009;17484000">
  <meta name="CHANGED" content="20061011;10243100">
  <link href="style/api_style.css" rel="stylesheet" type="text/css"
  media="all">
</head>

<body lang="en-US" dir="ltr">
<h1><a name="">WSO2 WSF/Ruby Manual</a></h1>

<h2><a name="Introduction">1. Introduction</a></h2>

<p><a href="http://wso2.com/" target="wso2_home">WSO2</a> Web Services Framework/Ruby (WSO2 WSF/Ruby) is the Ruby extension to the 
WSO2 Web Services Framework/C (<a href="http://www.wso2.org/projects/wsf/c" target="wsfc_home">WSF/C</a>). Using this Ruby extension, you can write Web Services consumer and provider applocations. WSF/Ruby supports SOAP 1.1, SOAP 1.2, SOAP MTOM,
WS-Addressing, WS-Security UsernameToken, WS-ReliableMessaging as well as REST style invocation. WSF/Ruby distinguishes itself being <b>the first and the only</b> Web Services Framework in Ruby to support this stack of WS specifications.</p>

<h2><a name="Requirements">2. Requirements</a></h2>
You should have the WSO2 WSF/C installed on your computer as a prerequisties to install and make use of WSF/Ruby.

<h2><a name="Installation">3. Installation</a></h2>

<p>This extension is available as an external extension. Please see the <a
href="install_guide.html">Installation Guide</a> for more information.</p>

<h2><a name="Runtime">4. Runtime and Compile time Configuration</a></h2>

<p>
You should have the following configuration entries in "rbconfig.rb" in order to use this extension.
</p>

<!--<p>
NOTE: Mostly "rbconfig.rb" can be found at /usr/lib/ruby/1.8/i686-linux/rbconfig.rb
</p>-->

<table border="1">
  <!--<caption>WSO2 WSF/Ruby Configuration Options</caption>-->
  <tbody>
    <tr>
      <th>Name</th>

      <th>Type</th>
      <th>Default</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>WSFC_HOME</td>
      <td>string</td>
      <td>"/opt/wso2/wsf"</td>
      <td>Location where WSO2 WSF/C is installed.</td>
    </tr>
    <tr>
      <td>WSF_LOG_DIR</td>
      <td>string</td>
      <td>"/tmp"</td>
      <td>Location where the log file are created. <br>
	      Every client can have its own log file. The log file name can be specified when the client is created.
	      If a log file name is not given the logs are written into a file called "wsf_ruby_client.log".<br>
	      Service logs are written into a file called "wsf_ruby_server.log".
      </td>
    </tr>
    <tr>
      <td>WSF_LOG_LEVEL</td>
      <td>string</td>
      <td>"3"</td>
      <td>This is an index that imposes a restriction on log messages that must get logged into the log file based on their level of severity.<br>
	  <br>
	  A guide to log levels :<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"0" - CRITICAL<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"1" - ERROR<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"2" - WARNING<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"3" - INFO<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"4" - DEBUG<br>
	  &nbsp;&nbsp;&nbsp;&nbsp;"5" - TRACE<br>
	  <br>
	  If your log level is x, then the messages with severity level 0 to x will get logged into the log file.
      </td>
    </tr>
    <tr>
      <td>WSF_RUBY_HOME</td>
      <td>string</td>
      <td>N/A</td>
      <td>Location where WSO2 WSF/Ruby installed. <br>
      </td>
    </tr>
  </tbody>
</table>


<h2><a name="Quick">5. Quick Start Guide</a></h2>

<p>This section is aimed to help you get a Web Service up quickly using WSO2
WSF/Ruby provider API and consume that service using WSO2 WSF/Ruby consumer API.</p>

<p>First follow the installation guide and get WSO2 WSF/Ruby working on your machine 
[<a href="install_guide.html">Installation Guide</a>]. Once you have installed the extension successfully,
you should be able to run Ruby scripts that are compliant with the WSO2 WSF/Ruby API specifications. <br>
</p>

<p>To start simple, let's see how to write a simple client to consume the 
<a href="http://flickr.com/services/api/">Flickr photo search service.</a></p>

<i>Step 1:</i><br>
<br>
First we need to prepare the payload, as expected by the service:
<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;x:FlickrRequest xmlns:x="urn:flickr"&gt;
            &lt;method&gt;flickr.photos.search&lt;/method&gt;
            &lt;api_key&gt;#{key}&lt;/api_key&gt;
            &lt;text&gt;Sri Lanka&lt;/text&gt;
	&lt;/x:FlickrRequest&gt;</span>
    <span style="color: brown;">XML</span>
</pre>

<p>In the above payload, you have to enter your flickr key in the
"key" element. The "text" element contains the words that we want to
search for.</p>

<p>
NOTE: You can create a flickr key <a href="http://flickr.com/services/api/"> here</a>
</p>

<i>Step 2:</i><br>

<p>
Next we need to create a WSClient, with the options to be used by the
client. For the Flickr photo service, we have to use only one option, i.e the endpoint
reference of the Flickr service.
</p>

<pre>
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">&quot;to&quot;</span> =&gt; <span style="color: rgb(255, 0, 0);">&quot;http://api.flickr.com/services/soap&quot;</span>});
</pre>

<p>
Here is the complete source code for the Flickr photo search [<a href="../samples/consumer/flickr.rb">
flickr.rb</a>]. Please remember to replace "somekey" string with a valid Flickr key.
</p>

<pre>
    <span style="color: rgb(0, 0, 255);">require</span> 'wsf'
    <span style="color: rgb(0, 0, 255);">include</span> WSO2::WSF

    key = <span style="color: red;">"somekey"</span>

    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;x:FlickrRequest xmlns:x="urn:flickr"&gt;
  	    &lt;method&gt;flickr.photos.search&lt;/method&gt;
  	    &lt;api_key&gt;#{key}&lt;/api_key&gt;
  	    &lt;text&gt;Sri Lanka&lt;/text&gt;
	&lt;/x:FlickrRequest&gt;</span>
    <span style="color: brown;">XML</span>
	
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">&quot;to&quot;</span> =&gt; <span style="color: rgb(255, 0, 0);">&quot;http://api.flickr.com/services/soap&quot;</span>});

    res_message = client.request(req_payload_string)

    <span style="color: rgb(0, 0, 255);">if not</span> res_message.<span style="color: rgb(0, 0, 255);">nil?</span> <span style="color: rgb(0, 0, 255);">then</span>
        <span style="color: rgb(0, 0, 255);">puts</span> <span style="color: red;">"Received OM : "</span> &lt;&lt; <span style="color: red;">"\n"</span> &lt;&lt; res_message.payload_to_s &lt;&lt; <span style="color: red;">"\n\n"</span>
    <span style="color: rgb(0, 0, 255);">end</span>
</pre>

<i>Step 3:</i><br>

<p>
To run the script just execute the following command in a terminal.
</p>

<pre>
    <span style="color: rgb(0, 0, 255);">ruby</span> flickr.rb
</pre>

<p>Now let's see how we can write a simple service and a client to consume that service using WSO2 WSF/Ruby. With these, you can learn the complete set of steps to write services and client using WSO2 WSF/Ruby.</p>

<h2 class="western"><a name="5.1.">5.1. Hello Service</a></h2>

<p>Let's see how to write your first Web Service with WSO2 WSF/Ruby.</p>

<p>
The deployment model for our service is going to be Ruby on Rails(RoR). So, it is a must thar you have RoR installed on your machine to deploy a service. Instructions for setting up RoR can be found <a href="http://www.rubyonrails.org/down">here</a>. You have to be familiar with the Model-View-Controller(MVC) architecture supported by Rails. After that you will be ready to write your first Web Service using WSO2 WSF/Ruby.
</p>

<p>The first service that we are going to write is named "hello" and would
have a single operation named "greet". This "greet" operation, when invoked
by a client, expects the client to send a greeting in request, and in turn 
sends a greeting in the response. The following are example XML payloads
exchanged between the client and the service:</p> 

<p>Request:</p>
<pre>
    <span style="color: rgb(0, 75, 0);">&lt;greet&gt;
        Hello Service! 
    &lt;greet&gt;</span>
</pre>
 
<p>Response:</p>
<pre>
    <span style="color: rgb(0, 75, 0);">&lt;greetResponse&gt;
        Hello Client!
    &lt;greetResponse&gt;</span>
</pre>

<p>The steps to be followed when implementing a service with WSO2 WSF/Ruby
include:</p>
<ol> 
  <li><b>Write the functions corresponding to the operations of the
    service.</b> <br> 
    In our sample, we will have one function that implements the "greet"
    operation. <br>
    We will name that function "greet".</li>
  <li><b>Create a WSService giving the operations and/or actions map along 
    with the options.</b><br>
    In our example, we have only one function, and we will use the name of
    the function as our operation name to keep things simple. <br>
    Hence, we will only use the operation map to specify our single
    operation. <br> 
  </li> 
  <li><b>Invoke the reply() method of the WSService class to invoke the
    operation and prepare the response.</b><br>
    This step is a simple method call to indicate to the service to start
    processing the request. This step is the same for all services.
  </li> 
</ol> 

<h3 class="western"><a name="5.1.1.">5.1.1. Operation Implementation</a></h3>


<p>Following is the implementation of the greet operation:</p> 

<pre>
    <span style="color: rgb(0, 0, 255);">def</span> greet(message)
        response_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
	    <span style="color: rgb(0, 75, 0);">&lt;greetResponse&gt;Hello Client!&lt;/greetResponse&gt;</span>
	<span style="color: brown;">XML</span>
    	
	<span style="color: rgb(0, 0, 255);">return</span> <span style="color: orange;">WSMessage</span>.<span style="color: rgb(0, 0, 255);">new</span>(response_payload_string)
    <span style="color: rgb(0, 0, 255);">end</span>
</pre>

<p>This function implements the business logic for the greet operation.
Basically this function receives the request payload as a "WSMessage" object
instance, prepares the response and returns it as a WSMessage instance.</p>

<h3 class="western"><a name="5.1.2.">5.1.2. Service Instance Creation with
Operations</a></h3> 

<p>A service can be created, specifying the operations as shown below:</p>

<pre>
    service = <span style="color: orange;">WSService</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"operations"</span> =&gt; {<span style="color: rgb(0, 150, 0);">"greet"</span> =&gt; <span style="color: red;">"greet"</span>}})
</pre>

<p>In the above code fragment, we create a service instance with the "greet"
operation. The "greet" function implemented above will be called when the
"greet" operation is invoked with the service. So in the association key is
the service operation name and the value is the corrosponding ruby function name.</p>

<p>
NOTE: You have to put the above code inside a function of your controller, in a way
we can specify the endpoint corrosponding to that function as the service endpoint.
</p>

<h3><a name="5.1.3.">5.1.3. Replying to Service Invocations</a></h3>

<p>The <i>reply()</i> method of the service has to be called by all service
implementations. This call would trigger the request processing on the server 
side and prepare the response to be sent to the client.</p> 
<p>
Here you have to pass two local variables <i>request</i> and <i>response</i> as the argument to
the reply method. Then it will return the response as a string, you can render it  back
using the 'render' method like in following code segment,
</p>

<pre>
    res = service.reply(request, response)
    <span style="color: blue;">render</span> :text =&gt; res
</pre>

<h3><a name="5.1.4.">5.1.4. Full Source</a></h3>

<p>Here is the complete source code for the service : <a
href="samples/hello_service.html">hello_service_controller.rb</a></p>

<h3><a name="5.1.5.">5.1.5. Deploying the Service</a></h3> 

<p>In order to make the service available to be consumed by clients, we have
to deploy the service. Before the deployment you should make sure the WSService 
is called inside a function in your controller. So if you are deploying rails with
<a href="http://www.webrick.org/">WEBRick</a> or <a href="http://mongrel.rubyforge.org/">Mongrel</a> servers, you just need to run the server (Running ./script/server
from the application root directory), and the services will be automatically deployed.
</p>

<p>
To verify that your service has been correctly deployed, you can start the
Web server and then browse for the service script using a Web browser. For
our sample, assuming the default values for the Web server, you can test the
service with <a  
href="http://localhost/hello_service/greet">http://localhost/hello_service/greet</a>.
Here the hello_services the name of the controller and the greet is a function inside
the controller where you create the WSService object.
You should get an entry for the hello_service/greet on the page that you
get.</p>  
</p>

<h2 class="western" style="margin-top: 0in; margin-bottom: 0in"><a name="5.2.">5.2. Hello Client</a></h2>

<p>Now that you know how to write a service with WSO2 WSF/Ruby, let's see how
you can write a client to consume that service. The request payload that the
client will be sending to the service was described in the previous section.
The client has to prepare the payload, send a request to the service and then
receive and process the response.</p>

<p>The steps to be followed when implementing a client with WSO2 WSF/Ruby
include:</p>
<ol>
  <li><b>Set the desired request payload and options.</b> <br>
    You can set the desired payload either in plain text form or as a WSMessage.
    Here we will demonstrate a simple consumer of the web service using request
    as a text.<br>
  </li>
  <li><b>Create a WSClient instance.</b><br>
    You can use the WSClient instance to consume the service. There we set options
    as arguments to the constructor.</li>
  <li><b>Send the request and receive the response.</b><br>
    Invoke the request() method passing the message as a parameter. This
    method returns a WSMessage instance, representing the response message.
    You can use member variables of the returned message instance to access
    the response in XML format. <br>
  </li>
  <li><b>Consume the response.</b><br>
    Process the response in line with the client business logic.</li>
</ol>

<h3><a name="5.2.1.">5.2.1. Preparing the Request Message</a></h3>

<pre>
    req_message = <span style="color: orange">WSMessage</span>.<span style="color: blue">new</span>(request_payload_string, 
				<span style="color: blue">nil</span>,
                                {<span style="color: green;">"to"</span> =&gt; <span style="color: red;">"http://localhost/hello_service/greet"</span>})</pre>

<p>In the above code fragment, a WSMessage instance is created with a payload
to be sent in the request and the service endpoint. The "to" element of the
options hash is mapped to the address of the location of the service. In
other words, the "to" address indicates where the request should be sent
to.</p>

<h3><a name="5.2.2.">5.2.2. Sending a Request and Receiving a
Response</a></h3>

<pre>
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({})
    res_message = client.request(req_message)
</pre>

<p>For sending a request with the output message created earlier, we need a
WSClient instance. We pass the message to be sent to the service to the
request() method. This will send the payload contained in the given message
and receive the response and return a message instance with the response
payload.</p>

<pre>
    <span style="color: blue;">puts</span> res_message.payload_to_s
</pre>

<p>In our client sample, we access the response payload as a string from the
returned message instance and display it.</p>

<h3><a name="5.2.3.">5.2.3. Full Source</a></h3>

<p>Here is the complete source code for the client : <a
href="samples/hello_client.html">hello_client.rb</a></p>

<h3><a name="5.2.4.">5.2.4. Running the Client</a></h3>

<p>To run the client, execute the following command on a terminal.</p>

<pre>
    <span style="color: blue;">ruby</span> hello_client.rb
</pre>

<h2><a name="Providing">6. Providing Web Services</a></h2>

<p>For providing Web services with WSO2 WSF/Ruby, using the XML in/out model,
you need to first define the request payload format and the response payload
format for each operation of the services that you intend to provide. For
each operation in a service, once those payload formats are defined, you have
to implement the functions that process the incoming request and generate the 
response message corresponding to each operation. When invoking a function
mapped to a service operation, WSO2 WSF/Ruby passes a WSMessage object instance to
that function and expects that function to return a WSMessage object
instance.
<br>
<br>
Hence the API for a user implemented function mapping to a service operation
is as follows.</p> 
<pre>
    <span style="color: orange;">WSMessage</span> user_defined_operation(<span style="color: orange;">WSMessage</span> payload)
    
    or
    
    <span style="color: orange;">String</span> user_defined_operation(<span style="color: orange;">WSMessage</span> payload)
</pre>

<p>Following code fragment shows an example:</p>

<pre>
    <span style="color: blue;">def</span> echoFunction(in_msg)
        ret_msg = <span style="color: orange;">WSMessage.<span style="color: blue;">new</span></span>(in_msg.payload_to_s)
        <span style="color: blue;">return</span> ret_msg
    <span style="color: blue;">end</span>
</pre>


<p>In the above sample, we just access the payload string in the incoming
message and place it in the return message, and return it. If you want to do 
further processing of the incoming payload, you could do that by processing
the str member of the incoming message.</p>

<p>Once the functions taking care of the business logic processing are
implemented, they need to be mapped to the operations of the service. There
are multiple ways of specifying this mapping.<br> 
The simplest form is to use the "operations" option and just give the
function name. You have to keep in mind that if you give only the function
name, WSO2 WSF/Ruby would assume the operation name to be the same as the
function name. <br>
</p>

<pre>
    operations = {<span style="color: green;">"echoString"</span> =&gt; <span style="color: red;">"echoFunction"</span>}
    server = <span style="color: orange;">WSService</span>.<span style="color: blue;">new</span>({<span style="color: green;">"operations"</span> =&gt; operations})
</pre>

<p>The importance of the operation name is that, in case WS-Addressing is not
in use, the Web services engine will resolve the operation to be invoked by
looking at the local name of the first child element of the request payload.
So, for the above service to respond to a request, the request payload's root
element must be "echoString".</p>


<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span> 
        <span style="color: rgb(0, 75, 0);">&lt;ns1:echoString xmlns:ns1="http://ruby.wsf.wso2.net/samples"&gt;
           &lt;text&gt;Hello World!&lt;/text&gt;
        &lt;/ns1:echoString&gt;</span>
    <span style="color: brown;">XML</span>
</pre>

<p>
In the context of WSO2 WSF/Ruby, a single Ruby script with WSService processing 
logic will be treated as a single service. Therefore in a service script,
there has to be only one call to the reply() method on top of a WSService
instance. The reply() method triggers the service to start processing the
request and prepare the response. Then you have to render the returned text from the 
reply method.</p>

<pre>
    <span style="color: rgb(128, 128, 128); font-style: italic;"># create service object instance</span>
    server = <span style="color: orange;">WSService</span>.<span style="color: blue;">new</span>({<span style="color: green;">"operations"</span> =&gt; {<span style="color: green;">"echoString"</span> =&gt; <span style="color: red;">"echoFunction"</span>}})
    
    <span style="color: rgb(128, 128, 128); font-style: italic;"># trigger request processing, call necessary methods and send a response back</span>
    res = server.reply(request, response)
    render <span style="color: green;">:text</span> =&gt; res
</pre>

<p>
As a given controller function would be bound to a single URL generated like following,
http://yourhost_name/controller_name/controller_function
when hosted with a Web server, that associated URL will naturally become the service endpoint of 
that Ruby script implementing the service logic.</p>

<p>As in the case of the client side, the WSO2 WSF/Ruby extension supports
more than just SOAP on the server side as well. You can use WS-Addressing,
XOP/MTOM and WS-Security UsernameToken when providing and consuming Web
services.</p> 

<p>The following sections explain how you can achieve more with the options
available for WSService.</p>

<h3><a name="6.1.">6.1. Using SOAP</a></h3>

<p>On the server side, you do not have to specify any options to use SOAP, 
rather based on the version of SOAP used in the client request, the service
will reply with the correct SOAP version. Hence when writing service Ruby
scripts, you do not have to bother about the SOAP version. <br>
</p>

<h3><a name="6.2.">6.2. Using REST</a></h3>

<p> On the server side, you do not have to specify any options to use REST, 
rather based on the client request, the service will provide the correct response.</p>

<h3><a name="6.3.">6.3. Payload Formats</a></h3>

<p>As mentioned earlier, the WSO2 WSF/Ruby engine invokes the user defined
function mapping to the operation with an instance of a WSMessage object. The 
function implementation representing the service's operation can choose to
consume the request in whatever format supported by the WSMessage class. <br>
When returning the response, the function implementation representing the
service's operation can choose to represent the response in whatever format
supported by the WSMessage class.</p>


<h3><a name="6.4.">6.4. Attachments with MTOM/XOP</a></h3> 

<p>When sending attachments, as in the case of the client side, you have to
use a WSMessage instance to represent payload, and give the binary data as an
array in the operation implementation function. When receiving attachments,
you can get the attachments received in the attachments array of the
WSMessage instance passed to the operation implementation function.</p> 

<p>For sending an attachment, you need to specify the element where the
attachment reference should be included in the payload.</p>

<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;ns1:attach xmlns:ns1="http://ruby.wsf.wso2.net/samples/mtom"&gt; 
            &lt;ns1:fileName&gt;test.jpg&lt;/ns1:fileName&gt;
            &lt;ns1:image xmlmime:contentType="image/jpeg" xmlns:xmlmime="http://www.w3.org/2004/06/xmlmime"&gt;
		&lt;xop:<span style="color: rgb(177, 177, 0);">Include</span> xmlns:xop="http://www.w3.org/2004/08/xop/include" <span style="color: rgb(177, 177, 0);">href</span>="cid:myid1"&gt;&lt;/xop:Include&gt;
            &lt;/ns1:image&gt;
        &lt;/ns1:attach&gt;</span>
    <span style="color: brown;">XML</span>
</pre> 

<p>In the above sample payload shown, by placing the "Include" element within
the "image" element, we specify that the attachment reference should be
included in the image element. The "href" attribute of the Include
element gives the ID of the attachment element in the attachments array of
the outgoing WSMessage instance. Once the payload is prepared, you have to 
create the message with the attachment data hash containing the binary data
to be attached.</p>

<pre>
    content = <span style="color: orange;">IO</span>.read(<span style="color: red;">"resources/axis2.jpg"</span>)
    
    res_message = <span style="color: orange;">WSMessage</span>.<span style="color: blue;">new</span>(res_payload_string,
				<span style="color: blue;">nil</span>,
                                {<span style="color:  rgb(0, 150, 0);">"attachments"</span> =&gt; {<span style="color:  rgb(0, 150, 0);">"myid1"</span> =&gt; content}})
</pre>

<p>In the above sample code fragment, we load the image contents to the "content"
variable and pass that variable to the attachments option when creating the
message. In the attachments associative array, you have to give the same ID
as was given in the "Include" element's "href" attribute in the payload. In
this sample, we use "myid1" as the ID.</p> 

<p>When sending attachments, you can configure the service to either send the
attachment in optimized format or in non-optimized format. If the attachment
is sent in binary optimized format, the file content would be sent as it is,
out of the SOAP body, using MIME headers and the payload would have an
XOP:Include element, referring to the MIME part that contains the binary 
attachment.<br>
In case of binary non-optimized format, the attachment content will be sent
in the payload itself, as a base64 encoded string.</p>

<pre> 
    <span style="color: rgb(128, 128, 128); font-style: italic;"># send attachments binary optimized</span>
    service = <span style="color: orange">WSService</span>.<span style="color: blue">new</span>({<span style="color: green;">"operations"</span> =&gt; operations,
                             <span style="color: green;">"use_mtom"</span> =&gt; <span style="color: blue;">true</span>})

    <span style="color: rgb(128, 128, 128); font-style: italic;"># send attachments binary non-optimized</span>
    service = <span style="color: orange">WSService</span>.<span style="color: blue">new</span>({<span style="color: green;">"operations"</span> =&gt; operations, 
                             <span style="color: green;">"use_mtom"</span> =&gt; <span style="color: blue;">false</span>})
</pre>

<p>When receiving attachments, the incoming message would have its 
attachments array set if there were MTOM optimized attachments in the
request. So the user implemented function mapping to the operation can access
them.</p>

<pre>
    <span style="color: blue">def</span> uploadFunction(in_msg)
        attachments = in_msg.property <span style="color: red">"attachments"</span>
  	cid_2_content_type = in_msg.property <span style="color: red">"cid_2_content_type"</span>

  	<span style="color: blue">if</span> attachments <span style="color: blue">and</span> cid_2_content_type <span style="color: blue">then</span>	
            cid_2_content_type.each_pair {|cid, content_type|
    	    content = attachments[cid]
    	    
            <span style="color: blue">if</span> content <span style="color: blue">then</span>			
      	        file_name = cid
      		file_name = file_name + <span style="color: red">".jpg"</span> <span style="color: blue">if</span> content_type == <span style="color: red">"image/jpeg"</span>

      		f = <span style="color: orange">File</span>.<span style="color: blue">new</span>(file_name, <span style="color: red">"w"</span>)
      		f.write(content)
      		f.close
    	    <span style="color: blue">end</span>	    
            }
  	<span style="color: blue">end</span>

  	res_payload_string = <span style="color: red">"&lt;ns1:response xmlns:ns1='http://ws.apache.org/axis2/c/samples'&gt;Image Saved&lt;/ns1:response&gt;"</span>

  	<span style="color: blue">return</span> res_payload_string
    <span style="color: blue">end</span>
</pre>

<p>In the above sample, the function responsible for processing the
attachments goes through the attachments array and saves each attachment if
it is a JPEG file. Once saved, it responds to the invoking client with the
response payload.</p> 

<h3><a name="6.5.">6.5. Using WS-Addressing</a></h3>

<p>Unlike on the client side, there is no need to enable WS-Addressing
explicitly on the server side. If the client request uses WS-Addressing, then
the server side would respond with WS-Addressing. However, in order to make 
WS-Addressing meaningful, you have to specify the WS-Addressing action
mapping for operations when constructing the service.</p>

<pre>
    operations = {<span style="color: green">"echoString"</span> =&gt; <span style="color: red">"echoFunction"</span>}
    actions = {<span style="color: green">"http://ruby.wsf.wso2.net/samples/echoString"</span> =&gt; <span style="color: red">"echoString"</span>}
 
    server = <span style="color: orange">WSService</span>.<span style="color: blue">new</span>({<span style="color: green">"operations"</span> =&gt; operations,  
                            <span style="color: green">"actions"</span> =&gt; actions})
</pre>

<!--
<pre><span style="color: rgb(0, 0, 255);">$operations</span> = <a href="http://www.php.net/array"><span style="color: rgb(0, 0, 102);">array</span></a><span style="color: rgb(102, 204, 102);">(</span><span style="color: rgb(255, 0, 0);">"echoString"</span> =&gt; <span style="color: rgb(255, 0, 0);">"echoFunction"</span><span style="color: rgb(102, 204, 102);">)</span>;
<span style="color: rgb(0, 0, 255);">$actions</span> = <a href="http://www.php.net/array"><span style="color: rgb(0, 0, 102);">array</span></a><span style="color: rgb(102, 204, 102);">(</span><span style="color: rgb(255, 0, 0);">"http://php.wsf.wso2.net/samples/echoString"</span> =&gt; <span style="color: rgb(255, 0, 0);">"echoString"</span><span style="color: rgb(102, 204, 102);">)</span>;
Â 
<span style="color: rgb(0, 0, 255);">$server</span> = <span style="color: rgb(0, 0, 0); font-weight: bold;">new</span> WSService<span style="color: rgb(102, 204, 102);">(</span><a href="http://www.php.net/array"><span style="color: rgb(0, 0, 102);">array</span></a><span style="color: rgb(102, 204, 102);">(</span><span style="color: rgb(255, 0, 0);">"operations"</span> =&gt; <span style="color: rgb(0, 0, 255);">$operations</span>,  
                              <span style="color: rgb(255, 0, 0);">"actions"</span> =&gt; <span style="color: rgb(0, 0, 255);">$actions</span><span style="color: rgb(102, 204, 102);">)</span><span style="color: rgb(102, 204, 102);">)</span>;</pre>

-->

<p>In the above sample code fragment, the WS-Addressing action mapping is set
for the echoString operation using the "actions" array. Note that it is not
to the function name, but to the operation name that the WS-Addressing action
is mapped.</p> 

<p>The client requests may be using different WS-Addressing versions. The
service reply will use the correct WS-Addressing version, based on the
version used by the client. You do not have to explicitly specify the
WS-Addressing version in the service script.</p>

<p>In addition to the action, the other WS-Addressing related SOAP headers 
that could be received in a message would be dealt with appropriately by the
underlying Web services engine. For example, if there is a replyTo set in the
incoming message, the reply would be sent to the specified replyTo
endpoint.</p>

<h3><a name="6.6.">6.6. One-Way Operations</a></h3>

<p>You can make your service operations adhere to either the in-out message 
exchange pattern or the in-only message exchange pattern. If a function
mapped to an operation returns a WSMessage instance, then that operation is
treated as an in-out operation. If a function mapped to an operation returns
void, then that operation is treated as an in-only operation.<br>
We have seen functions adhering to in-out message exchange pattern in samples
given in the above sections including the quick start guide. The following is 
a sample of an in-only operation. .</p>

<pre>
    <span style="color: blue;">def</span> notify_function<span>(in_message)
        <span style="color: rgb(128, 128, 128); font-style: italic;"># Do your processing here</span>
        
        <span style="color: blue;">return</span>
    <span style="color: blue;">end</span>
</pre>

<p>In the above sample, the notify function accepts the payload sent by the
client and consumes it, and does not send any response.</p>

<h2><a name="Consuming">7. Consuming Web Services</a></h2>

<p>For consuming Web services with WSO2 WSF/Ruby, using the XML in/out model,
you need to first find out the request payload format and the response
payload format. You also need to know the service endpoint URI.<br>
Once this information is available, you can construct a WSMessage instance
with the payload and service endpoint URI information. These are the minimum
requirements for consuming a Web Service. These basics were explained in the
quick start guide.
</p>

<p>The advantage of using the WSO2 WSF extension is that it supports more
than just SOAP. You can use WS-Addressing, XOP/MTOM and WS-Security
UsernameToken when providing and consuming Web services. You can also invoke
services using REST style calls.</p>

<p>The following sections explain how you can achieve more with the options
available for WSMessage and WSClient.</p>

<h3><a name="7.1.">7.1. Using SOAP</a></h3>

<p>You can use the "use_soap" option at client level to specify the SOAP
version to be used. If this option is not set, the default SOAP version used
is SOAP 1.2. <br>
</p>

<p>There are multiple ways of setting the SOAP version, you can use any one
of them.</p>

<pre>
    <span style="color: rgb(128, 128, 128); font-style: italic;"># setting SOAP 1.2 version</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">true</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">1.2</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:red;">"1.2"</span>})

    <span style="color: rgb(128, 128, 128); font-style: italic;"># setting SOAP 1.1 version</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">1.1</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:red;">"1.1"</span>})
</pre>

<p>There is another option named "http_method", that you can use to specify
the HTTP method to be used. When SOAP is in use, the default HTTP method used
will be "POST" all the time. If you specify "GET" when SOAP is in use, then
no request will be sent, because WSO2 WSF/Ruby does not support SOAP with HTTP
GET.</p>

<h3><a name="7.2.">7.2. Using REST</a></h3>

<p>If you want to consume Web services using REST style calls, that can be
done by setting the "use_soap" option to "false". In case of REST style of
invocation, you can use either the HTTP POST method or the HTTP GET method.
<br>
</p>

<p>The following example shows how to enable a REST style invocation using
different HTTP methods.</p>

<pre>
    <span style="color: rgb(128, 128, 128); font-style: italic;"># REST with HTTP POST</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">false</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">false</span>, <span style="color: green;">"http_method"</span> =&gt; <span style="color: red;">"POST"</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">false</span>, <span style="color: green;">"http_method"</span> =&gt; <span style="color: red;">"post"</span>})

    <span style="color: rgb(128, 128, 128); font-style: italic;"># REST with HTTP GET</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">false</span>, <span style="color: green;">"http_method"</span> =&gt; <span style="color: red;">"GET"</span>})
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_soap"</span> =&gt; <span style="color:blue;">false</span>, <span style="color: green;">"http_method"</span> =&gt; <span style="color: red;">"get"</span>})
</pre>

<h3><a name="7.3.">7.3. Payload Formats</a></h3>

<p>When invoking Web Services, the WSO2 WSF/Ruby extension allows you to
provide the message payload as an XML string, as a WSMessage object or as a REXML document object.</p>

<p>Using a string as the request payload:</p>
<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;ns1:echoString xmlns:ns1="http://ruby.wsf.wso2.net/samples"&gt;
            &lt;text&gt;Hello World!&lt;/text&gt;
	&lt;/ns1:echoString&gt;</span>
    <span style="color: brown;">XML</span>

    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: green;">"to"</span> =&gt; <span style="color: red;">"http://localhost/hello_service/greet"</span>})
                                
    res_message = client.request(req_payload_string)
</pre>

<p>Using a WSMessage instance as the request payload:</p>
<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;ns1:echoString xmlns:ns1="http://ruby.wsf.wso2.net/samples"&gt;
            &lt;text&gt;Hello World!&lt;/text&gt;
	&lt;/ns1:echoString&gt;</span>
    <span style="color: brown;">XML</span>

    req_message = <span style="color: orange;">WSMessage</span>.<span style="color: blue;">new</span>(req_payload_string)

    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: green;">"to"</span> =&gt; <span style="color: red;">"http://localhost/hello_service/greet"</span>})
                                
    res_message = client.request(req_message)
</pre>

<p>Using a REXML Document instance as the request payload:</p>
<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;ns1:echoString xmlns:ns1="http://ruby.wsf.wso2.net/samples"&gt;
            &lt;text&gt;Hello World!&lt;/text&gt;
	&lt;/ns1:echoString&gt;</span>
    <span style="color: brown;">XML</span>

    req_message = <span style="color: orange;">REXML::Document</span>.<span style="color: blue;">new</span>(req_payload_string)

    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: green;">"to"</span> =&gt; <span style="color: red;">"http://localhost/hello_service/greet"</span>})
                                
    res_message = client.request(req_message)
</pre>

<!--<p>The WSO2 WSF/PHP extension only supports the XML in/out model for
consuming services currently. Data binding for PHP will be supported in a
future release. <br>
</p>-->

<h3><a name="7.4.">7.4. Attachments with MTOM/XOP</a></h3>

<p>WSO2 WSF/Ruby allows you to send and receive binary data with SOAP messages
using MTOM/XOP conventions. When sending attachments, you have to use a
WSMessage instance to represent the payload, and give the binary data as an
array. When receiving attachments, you can get the attachments received from
the attachments array of the WSMessage instance returned.</p>

<p>
For sending an attachment, you need to specify the element where the
attachment reference should be included in the payload.</p>

<pre>
    req_payload_string = &lt;&lt;<span style="color: brown;">XML</span>
        <span style="color: rgb(0, 75, 0);">&lt;ns1:attach xmlns:ns1="http://ruby.wsf.wso2.net/samples/mtom"&gt; 
            &lt;ns1:fileName&gt;test.jpg&lt;/ns1:fileName&gt;
            &lt;ns1:image xmlmime:contentType="image/jpeg" xmlns:xmlmime="http://www.w3.org/2004/06/xmlmime"&gt;
		&lt;xop:<span style="color: rgb(177, 177, 0);">Include</span> xmlns:xop="http://www.w3.org/2004/08/xop/include" <span style="color: rgb(177, 177, 0);">href</span>="cid:myid1"&gt;&lt;/xop:Include&gt;
            &lt;/ns1:image&gt;
        &lt;/ns1:attach&gt;</span>
    <span style="color: brown;">XML</span>
</pre>

<p>In the above sample payload shown, by placing the "Include" element within
the "image" element, we specify that the attachment reference should be
included in the "image" element. The "href" attribute of the "Include"
element gives the ID of the attachment element in the attachments array of
the outgoing WSMessage instance. Once the payload is prepared, you have to
create the message with the attachment data array containing the binary data
to be attached.</p>

<pre>
    content = <span style="color: orange;">IO</span>.read(<span style="color: red;">"resources/axis2.jpg"</span>)

    req_message = <span style="color: orange;">WSMessage</span>.<span style="color: blue;">new</span>(req_payload_string,
				<span style="color: blue;">nil</span>,
                                {<span style="color:  rgb(0, 150, 0);">"attachments"</span> =&gt; {<span style="color:  rgb(0, 150, 0);">"myid1"</span> =&gt; content}})</pre>

<p>In the above sample code fragment, we load the image contents to the "content"
variable and pass the variable to the attachments option when creating the
message. In the attachments associative array, you have to give the same ID
as was given in the "Include" element's "href" attribute in the payload. In
this sample, we use "myid1" as the ID.</p>

<p>When sending attachments, you can configure the client either to send the
attachment in the optimized format or in non-optimized format. If the
attachment is sent in binary optimized format, the file content will be sent
as it is, out of the SOAP body, using MIME headers and the payload would have
an XOP:Include element, referring to the MIME part that contains the binary
attachment.<br>
In case of binary non-optimized format, the attachment content will be sent
in the payload itself, as a base64 encoded string.</p>

<pre>
    <span style="color: rgb(128, 128, 128); font-style: italic;"># send attachments binary optimized</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_mtom"</span> =&gt; <span style="color: blue;">true</span>})

    <span style="color: rgb(128, 128, 128); font-style: italic;"># send attachments binary non-optimized</span>
    client = <span style="color: orange">WSClient</span>.<span style="color: blue">new</span>({<span style="color: green;">"use_mtom"</span> =&gt; <span style="color: blue;">false</span>})</pre>

<h3><a name="7.5.">7.5. Using WS-Addressing</a></h3>

<p><a href="http://www.w3.org/2002/ws/addr/">WS-Addressing</a> provides
mechanisms to address Web Services and messages. With WSO2 WSF/Ruby, you can
use both WS-Addressing <a href="http://www.w3.org/TR/ws-addr-core/">version
1.0</a> as well as the <a href="http://www.w3.org/Submission/ws-addressing/">submission version</a>.</p>

<p>There are two basic requirements that you have to specify when using WS-Addressing on the client
side with WSO2 WSF/Ruby. One is that you have to provide a WS-Addressing
action at message level. The other is that you have to enable the use of
WS-Addressing at client level.</p>

<pre>
    req_message = <span style="color: orange;">WSMessage</span>.<span style="color: blue;">new</span>(req_payload_string,
				<span style="color: blue;">nil</span>,
				{<span style="color: rgb(0, 150, 0);">"to"</span> =&gt; <span style="color: red;">"http://localhost/echo_service_addr/echo"</span>,
                                 <span style="color: rgb(0, 150, 0);">"action"</span> =&gt; <span style="color: red;">"http://ruby.wsf.wso2.net/samples/echoString"</span>})
              
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: blue;">true</span>})
</pre>

<p>In the above sample code fragment, the WS-Addressing action is set
using the "action" array element of the options array passed to the WSMessage
constructor. WS-Addressing is enabled with the "use_wsa" option passed to the
WSClient constructor.</p>

<p>You can choose to use different addressing versions. For that you
have to use one of the possible options shown below.</p>

<pre>
    <span style="color: rgb(128, 128, 128); font-style: italic;"># Setting WS-Addressing 1.0</span>
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: blue;">true</span>})
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: blue;">1.0</span>})
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: red;">"1.0"</span>})
	
    <span style="color: rgb(128, 128, 128); font-style: italic;"># Setting WS-Addressing submission</span>
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: red;">"submission"</span>})
</pre>

<p>In addition to the action, there are other WS-Addressing related SOAP
headers that can be sent in a message. WSO2 WSF/Ruby has support to set those
headers as properties at the message level or as options at the client level.
An example is shown below.</p>

<pre>
    req_message = <span style="color: orange;">WSMessage</span>.<span style="color: blue;">new</span>(req_payload_string,
                                <span style="color: blue;">nil</span>,
	                        {<span style="color: rgb(0, 150, 0);">"to"</span> =&gt; <span style="color: red;">"http://www.company_foo.com/order_processing/process"</span>,
	                         <span style="color: rgb(0, 150, 0);">"action"</span> =&gt; <span style="color: red;">"http://ruby.wsf.wso2.net/samples/order"</span>,
	                         <span style="color: rgb(0, 150, 0);">"from"</span> =&gt; <span style="color: red;">"http://www.company_bar.com/order_placing/place"</span>,
	                         <span style="color: rgb(0, 150, 0);">"reply_to"</span> =&gt; <span style="color: red;">"http://www.company_bar.com/billing/bill"</span>,
	                         <span style="color: rgb(0, 150, 0);">"fault_to"</span> =&gt; <span style="color: red;">"http://www.company_bar.com/re_odering/order"</span>})

    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: rgb(0, 150, 0);">"use_wsa"</span> =&gt; <span style="color: blue;">true</span>})
</pre>

<p>In the above example, company "bar" sends a purchase order to company
"foo" from the place order client. If the service invocation is successful,
company foo would send the bill to the billing service of company bar; if the
order failed, re-ordering service of company bar would be sent the fault details
which would decide how to place the order again. WS-Addressing helps us to
manage the order process, with replies and faults being directed to
different endpoints.</p>

<h3><a name="7.6.">7.6. WS-Security</a></h3>

<p>With WSPolicy and WSSecurityToken, you can use WS-Security usernameTokens,
encryption, signing, along with timestamp, time-to-live and digest support.
The simplest form of using usernameToken is to provide a username and a
password.</p>

<pre>
    policy_obj = <span style="color: orange;">WSPolicy</span>.<span style="color: blue;">new</span>({<span style="color: green;">"use_username_token"</span> => <span style="color: blue;">true</span>})

    security_obj = <span style="color: orange;">WSSecurityToken</span>.<span style="color: orange;">new</span>({<span style="color: green;">"user"</span> => <span style="color: red;">"john"</span>,
                                        <span style="color: green;">"password"</span> => <span style="color: red;">"fred"</span>})
</pre>

Or else, you can use the password call back mechanism by using a callback

<pre>
    <span style="color: blue;">def</span> password_function(username)    
        <span style="color: rgb(128, 128, 128); font-style: italic;"># some  mechanism to retrieve the password</span>   
    <span style="color: blue;">end</span>
</pre>

Then WSSecurityToken object would be<br>

<pre>
    security_obj = <span style="color: orange;">WSSecurityToken</span>.<span style="color: blue;">new</span>({<span style="color: green;">"user"</span> => <span style="color: red;">"john"</span>,
                                        <span style="color: green;">"password_callback"</span> => <span style="color: red;">"password_function"</span>})
</pre>

If you want the timetoLive and timestamp , those options also can be
specified.<br>

<pre>
    policy_obj = <span style="color: orange;">WSPolicy</span>.<span style="color: blue;">new</span>({<span style="color: green;">"use_username_token"</span> => <span style="color: blue;">true</span>,
                               <span style="color: green;">"include_timestamp"</span> => <span style="color: blue;">true</span>})

    security_obj = <span style="color: orange;">WSSecurityToken</span>.<span style="color: blue;">new</span>({<span style="color: green;">"user"</span> => <span style="color: red;">"john"</span>,
                                        <span style="color: green;">"password"</span> => <span style="color: red;">"fred"</span>,
                                        <span style="color: green;">"ttl"</span> => <span style="color: blue;">300</span>})

</pre>

<h3><a name="7.7.">7.7. One-Way Clients</a></h3>

<p>The request() method of WSClient that you have seen in the samples so far
adheres to the out-in message exchange patterns. That means, when the client
sends a request, it expects a response back.<br>
Out-only message exchange pattern is another popular pattern when consuming
services. In the out-only model, the client sends a request but does not
expect a response back. The send() method of WSClient supports this message
exchange pattern.</p>

<pre>
    client = <span style="color: orange;">WSClient</span>.<span style="color: blue;">new</span>({<span style="color: green;">"to"</span> => <span style="color: red;">"http://localhost/notify_service/notify"</span>})
                                
    client.send(req_payload_string)
    
    <span style="color: blue;">puts</span> <span style="color: red;">"Request sent\n"</span>
</pre>

<p>In the above sample, the notify service accepts the payload sent by the
client and consumes it, and will not send any response. The return type of
send() is void. In case of errors, it would throw a fault.</p>

</body>
</html>
